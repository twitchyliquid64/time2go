function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
  var angleInRadians = (angleInDegrees-90) * Math.PI / 180.0;

  return {
    x: centerX + (radius * Math.cos(angleInRadians)),
    y: centerY + (radius * Math.sin(angleInRadians))
  };
}

function describeArc(x, y, radius, startAngle, endAngle){

    var start = polarToCartesian(x, y, radius, endAngle);
    var end = polarToCartesian(x, y, radius, startAngle);

    var arcSweep = endAngle - startAngle <= 180 ? "0" : "1";

    var d = [
        "M", start.x, start.y,
        "A", radius, radius, 0, arcSweep, 0, end.x, end.y
    ].join(" ");

    return " " + d;
}


function genSvgHeader(bounds, options){
  var width = bounds.maxx - bounds.minx + 20;
  var height = bounds.maxy - bounds.miny + 20;

  var s = '<?xml version="1.0" encoding="iso-8859-1"?>' + '\n';
  s += '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 20001102//EN"' + '\n';
  s += '"http://www.w3.org/TR/2000/CR-SVG-20001102/DTD/svg-20001102.dtd">' + '\n';
  s += '\n';
  s += '<!-- File generated by ddlCAD SVG Renderer -->' + '\n';
  s += '\n';
  s += '<svg ';
  if (options.preview == true) {
    s += ' width="100%" height="100%" viewBox="0 0 ' + width + ' ' + height + '"';
  } else {
    s += ' width="' + width + '" height="' + height + '"'
  }
  s += ' xmlns="http://www.w3.org/2000/svg" version="1.1">' + '\n';

  if(options.preview == true){
    s += '\t<g transform="translate(' + ((-1 * bounds.minx)+10) + ', ' + ((-1 * bounds.miny)+10) + ')">' + '\n';
  }
  return s
}

function genSvgTrailer(bounds, options){
  var s = '';
  if (options.preview == true){
    s += '\t</g>' + '\n';
  }
	s += '</svg>' + '\n';
  return s;
}

function genSvgForPath(bounds, options, path, pathName){
  var s = '';
  if (options.preview == true){
    s += '\t';
  }
  s += '\t<path d="';

  var lastx = -342861243;
  var lasty = -324312432;
  var checkCoordLoc = function(x,y){
    if ((lastx != x) || (lasty != y)){
      s += " M" + x + " " + y;
    }
    lastx = x;
    lasty = y;
  }

  for(var i = 0; i < path.length; i++) {
    var op = path[i];
    switch (op.type) {
      case 'line':
        checkCoordLoc(op.startx, op.starty);
        s += " L" + op.endx + " " + op.endy;
        lastx = op.endx;
        lasty = op.endy;
        break;

      case 'circle':
        checkCoordLoc(op.x, op.y);
        s += " m " + String(-1 * op.radius) + ", 0";
        s += " a " + String(op.radius) + "," + String(op.radius) + " 0 1,1 " + String(op.radius * 2) + ",0";
        s += " a " + String(op.radius) + "," + String(op.radius) + " 0 1,1 " + String(op.radius * -2) + ",0";
        lastx = -342861243;
        lasty = -324312432;
        break;

      case 'arc':
        s += describeArc(op.x, op.y, op.radius, op.startAng, op.endAng);
        lastx = -342861243;
        lasty = -324312432;
        break;
    }
  }

  s += '"'
  s += ' stroke="black" fill="none" stroke-width="1" id="' + pathName + '"'
  s += ' />\n';

  return s;
}

(function(){
  ddlRenderTargets['svg'] = function(execOutputContext, options){
    var bounds = parsePathsForMaxMin(execOutputContext);
    var svgout = genSvgHeader(bounds, options);

    var paths = execOutputContext.paths;
    for (var pathName in paths) {
      if (paths.hasOwnProperty(pathName)) {
        var path = paths[pathName];
        svgout += genSvgForPath(bounds, options, path, pathName);
      }
    }

    svgout += genSvgTrailer(bounds, options);
    console.log(svgout);
    return svgout;
  }
})();
